% Created 2022-05-23 Mon 14:31
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Ali, Mihir, Noah}
\date{\today}
\title{Einführung in die Theoretische Informatik Zusammenfassung}
\hypersetup{
 pdfauthor={Ali, Mihir, Noah},
 pdftitle={Einführung in die Theoretische Informatik Zusammenfassung},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Formale Sprachen}
\label{sec:org2043d4d}

\subsection{Grundbegriffe}
\label{sec:orgfb6ed98}
\begin{itemize}
\item Alphabet \(\Sigma\) (endliche Menge) z.B. \(\{1,0\}\)
\item Wort/String über \(\Sigma\) ist eine endliche Folge von Zeichen aus \(\Sigma\)
\item \(|w|\) länge des Wortes \(w\)
\item Leeres Wort \(\epsilon\)
\item \(uv\) konkatenation der Wörter \(u\) und \(w\)
\item Ist \(w\) ein Wort so ist \(w^0 = \epsilon\) und \(w^{n+1} = ww^n\)
\item \(\Sigma^*\) Menge aller Wörter über \(\Sigma\)
\item (formale) Sprache \(L \subseteq \Sigma^*\)
\end{itemize}

\subsubsection{Operationen auf Sprachen}
\label{sec:orgbfb38fe}
Seien \(A,B \subseteq \Sigma^*\)
\begin{itemize}
\item Konkatenation:
\end{itemize}
\(AB = \{uv | u \in A \land v \in B \}\)
\begin{itemize}
\item Konkatenation mit sich selbst:
\end{itemize}
\(A^n = \{w_1 ... w_n | w_1, ... , w_n \in A\} = A ... A\)
\begin{itemize}
\item \(A^* = \{w_1...w_n | n \geq 0 \land w_1, ... , w_n \in A\} = \bigcup_{n\in \mathbb{N}} A^n\)
\item \(A^+ = AA^* = \bigcup_{n \geq 1} A^n\)
\end{itemize}
\begin{enumerate}
\item Sonderfälle:
\label{sec:orga8c3f51}
\begin{itemize}
\item \(\forall A: \epsilon \in A^*\)
\item \(\emptyset^* = \{\epsilon\}\)
\item \(\emptyset A = \emptyset\)
\item \(\{\epsilon \} A = A\)
\item \(A^*A^* = A^* = (A^*)^*\)
\end{itemize}
\end{enumerate}

\subsubsection{Grammatiken}
\label{sec:org5c1bfb8}
4-Tupel \(G = (V,\Sigma,P,S)\)
\begin{itemize}
\item \(V\) ist endliche Menge von Nichtterminalzeichen
\item \(\Sigma\) ist endliche Menga von Terminalzeichen (= Alphabet)
\item \(P \subseteq (V \cup \Sigma)^* \times (V \cup \Sigma)^*\) ist Menge von Produktionen
\item \(S \in V\) ist das Startsymbol
\end{itemize}

Die Sprache von G ist die Menge aller Wörter, die von G erzeugt werden. Sie wird mit \(L(G)\) bezeichnet.
Also jedes Wort, dass die Grammatik erzeugt muss in der Sprache erhalten sein und jedes Wort in der Sprache muss von der Grammatik erzeugt werden.
\begin{enumerate}
\item Reflexve transitive Hülle
\label{sec:org96c32bd}

\begin{itemize}
\item \(\alpha \rightarrow^0_G \alpha\)
\item \(\alpha \rightarrow^{n+1}_G \gamma: \exists \beta. \alpha \rightarrow^n_G \rightarrow_G \gamma\)
\item \(\alpha \rightarrow^{*}_G \beta : \exists n. \alpha \rightarrow^n_G \beta\)
\item \(\alpha \rightarrow^{+}_G \beta: \exists n>0. \alpha \rightarrow^n_G \beta\)
\end{itemize}
\end{enumerate}

\subsubsection{Chomsky Hierarchie}
\label{sec:org2d35577}
Eine Grammatik G ist vom
\begin{itemize}
\item Typ 0 immer
\item Typ 1 falls fpr jede Produktion \(\alpha \rightarrow \beta\) außer \(S \rightarrow \epsilon\) gilt \(|\alpha| \leq |\beta|\)
\item Typ 2 Falls G vom typ 1 ist und für jede Produktion \(\alpha \righarrow \beta\) gilt \(\alpha \in V\)
\item Typ 3 falls G vom Typ 2 ist und für jede Produktion \(\alpha \rightarrow \beta\) außer \(S \rightarrow \epsilon\) gilt \(\beta \in \Sigma \cup \Sigma V\)
\end{itemize}

\begin{enumerate}
\item Grmmatiken und Sprachklassen:
\label{sec:org02e8258}
\begin{center}
\begin{tabular}{lll}
Typ 3 & Rechtslineare Grammatiken & Reguläre Sprachen\\
Typ 2 & Kontextfreie Grammatik & Kontextfreie Sprachen\\
Typ 1 & Kontextsensitive Grammatik & Kontextsens. Sprachen\\
Typ 0 & Phrasenstrukturgrammatik & Rekursiv aufzählbare Sprachen\\
\end{tabular}
\end{center}

\item Satz 2.13
\label{sec:org0ce1d5c}
\(L(Typ 3) \subset L(Typ 2) \subset L(Typ 1) \subset L(Typ 0)\)
\end{enumerate}

\subsubsection{Wortproblem}
\label{sec:orgca767e7}
Gegeben: eine Grammatik G, ein Wort \(w \in \Sigma^*\)
Frage: Ist das Wort in w enthalten (\(w \in L(G)\))?

\section{Reguläre Sprachen}
\label{sec:orgcd1467d}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{./img/2-kapitel/reguläre_sprachen.png}
\caption{Reguläre Sprachen Schema}
\end{figure}

\subsection{Deterministische endliche Automaten}
\label{sec:orgb58415b}
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{./img/2-kapitel/automat_bsp.png}
\caption{Beispiel Automat}
\end{figure}

\begin{itemize}
\item Beispiel:
\begin{itemize}
\item Eingabewort \(baba \rightarrow\) Zustandsfolge 0,0,1,2,2
\end{itemize}
\item ``Bei dieser Grammatik muss mindestens nach einem a ein b kommen''
\item Die Sprache des DFA ist die Menge aller Wörter über \(\{a,b\}\), die ab enthalten
\end{itemize}

Erkannte Sprache: Menge der Wörter, die vom Startzustand in einen Endzustand führen.
Recognizer, die nur einmal das Wort durchläuft und in linearer Zeit es akzeptiert oder ablehnt.

\subsubsection{Definition}
\label{sec:org742cc5a}
Ein deterministischer endlicher Automat \(M = (Q,\Sigma, \delta, q_0, F)\) besteht aus
\begin{itemize}
\item endliche Menge von Zuständen Q
\item endlichem Eingabealphabet \(\Sigma\)
\item einer totalen Übergangsfunktion \(\delta: Q \times \Sigma \rightarrow Q\)
\item eienm Startzustand \(q_0 \in Q\)
\item einer Menge \(F \subset Q\) von Endzuständen
\end{itemize}

\begin{enumerate}
\item Akzeptierte Sprachen (Definition 3.2)
\label{sec:orge1dd855}
Von M akzeptierte Sprache \(L(M) := \{w \in \Sigma^* | \hat{\delta}(q_0, w) \in F\}\) wobei \\
\(\hat{\delta}: Q \times \Sigma^* \rightarrow Q\) induktiv definiert ist: \\
\(\hat{\delta}(q,\epsilon) = q\) \\
\(\hat{\delta}(q,aw) = \hat{\delta}(\delta(q,a),w)\), für \(a \in \Sigma, w \in \Sigma^*\) \\
(\(\hat{\delta}(q, w)\) bezeichnet den Zustand, den man aus \(q\) mit \(w\) erreicht.)\\
Eine Sprache ist regulär \textbf{gdw} sie von einem DFA akzeptiert wird.

\item Beispiel Automat der Sprache akzeptiert
\label{sec:orgba81a5a}
Induktiv beweisen pro Zustand.
\end{enumerate}


\subsection{Von rechtslinearen Grammatiken zu DFA}
\label{sec:org27acd92}
\begin{itemize}
\item Für jede rechtslineare Grammatik \(G\) gibt es einen DFA \(M\) mit \(L(M) = L(G)\)
\item Für jeden DFA \(M\) gibt es eine rechtslineare Grammatik \(G\) mit \(L(G) = L(M)\)
\end{itemize}

\subsubsection{Nichtdeterministischer endlicher Automat}
\label{sec:orga1608fd}
Ein deterministischer endlicher Automat \(M = (Q,\Sigma, \delta, q_0, F)\) besteht aus
\begin{itemize}
\item \(Q, \Sigma, q_0, F\) sind wie DFA
\item \(\delta: Q \times \Sigma \rightarrow P(Q)\) \\
\(P(Q)\) = Menge aller Teilmengen von \(Q = 2^Q\) \\
Alternative: Relation \(\delta \subseteq Q \times \Sigma \times Q\)
\end{itemize}


\(\bar{\delta}(S,a) := \bigcup_{q \in S} \delta(q,a)\)


Es folgt: \(\hat{\bar{\delta}}: P(Q) \times \Sigma^* \rightarrow P(Q)\)

\begin{enumerate}
\item Intuition:
\label{sec:org0d004c7}
\(\hat{\bar{\delta}}(S,w)\) ist Menge aller Zustände, die sich von einem Zustand in S aus \(w\) erreichen lassen.

\item Von nichtdeterminitsichen Automaten N akzeptierte Sprache
\label{sec:orgbeef1be}
\(L(N) := \{w \in \Sigma^* | \hat{\bar{\delta}}(\{q_0\},w) \cap F \neq \emptyset\}\)
\end{enumerate}

\subsubsection{Satz 3.9}
\label{sec:org0f3b3af}
Für jede rechtslineare Grammatik G gibt es einen NFA M mit \(L(G) = L(M)\)
\subsubsection{Satz 3.13}
\label{sec:org54c04ac}
Für jeden DFA M gibt es eine rechtslineare Grammatik G mit \(L(M) = L(G)\)

\subsection{3.3 NFAs mit \(\epsilon\) -Übergängen}
\label{sec:orgabd2222}
Grammatiken von Programmiersprachen enthalten viele Produktionen der Gestalt \(A \rightarrow B\).

Ein NFA mit \textbf{\(\epsilon\)}-Übergängen (auch \(\epsilon\) -NFA) ist ein NFA mit einem speziellen Symbol \(\epsilon \not \in \Sigma\) und mit
\(\delta : Q \times (\Sigma \cup {\epsilon}) \rightarrow P(Q)\) .
Ein \(\epsilon\) übergang darf ausgef¨uhrt werden, ohne dass ein

\subsubsection{Lemma 3.16}
\label{sec:orge8aacd4}
Für jeden \(\epsilon\) -NFA \(N\) gibt es einen NFA \(N'\) mit \(L(N) = L(N')\).

\subsection{3.4 Regex}
\label{sec:org96c4a6f}
\begin{itemize}
\item \(\emptyset\) ist ein regex
\item \(\epsilon\) ist ein regex
\item Für jedes \(a \in \Sigma\) ist a ein regulärer Audruck
\item Wenn \(\alpha\) und \(\beta\) regex dann auch
\begin{enumerate}
\item \(\alpha \beta\)
\item \(\alpha | \beta\)
\item \(\alpha^*\)
\end{enumerate}
\item Sonst NIX!
\end{itemize}
\subsubsection{Definition 3.20}
\label{sec:org11208ac}
Zu einem regulären Ausdruck \(\gamma\) ist die zugehörige Sprache \(L(\gamma)\) rekursiv definiert:
\begin{itemize}
\item \(L(\emptyset) =\emptyset\)
\item \(L(\epsilon) = \{\epsilon\}\)
\item \(L(a) = {a}\)
\item \(L(\alpha \beta) = L(\alpha)L(\beta))\)
\item \(L(\alpha | \beta) = L(\alpha) \cup L(\beta)\)
\item \(L(\alpha^*) = L(\alpha)^*\)
\end{itemize}

\subsubsection{Satz 3.23 (Kleene 1956)}
\label{sec:org21eeb75}
Eine Sprache \(L \subseteq \Sigma^*\) ist genau dann durch einen regulären Ausdruck darstellbar, wenn sie regulär ist.\\
\smallindent
\(R^{k+1}_{ij} = R^k_{ij} \cup R^k_{i(k+1)}(R^k_{(k+1)(k+1)})^*R^k_{(k+1)j}\) \emph{in regex \(\cup = |\)}\\
\(R^{k+1}_{ij}\) = alle Wörter die in \(R^k_{ij}\) sind plus alle Wörter die mindestens einmal \(q_{k+1}\) besuchen
Somit gilt \(L(M) = L(\alpha^n_{1i_1} | ... | \alpha^n_{1i_r})\), wobei \(F=\{i_1, ..., i_r\}\)


\subsubsection{Wie teuer sind unsere Konversionen?}
\label{sec:org83191c1}
\begin{center}
\includegraphics[width=.9\linewidth]{./img/2-kapitel/konversionen.png}
\end{center}
\begin{itemize}
\item RE \(\rightarrow \epsilon\) -NFA: RE der Länge n, \(O(n)\) Zustände
\item \(\epsilon\) -NFA \(\rightarrow\) NFA: Q
\item NFA \(\rightarrow\) DFA: \(O(2^n)\)
\item FA \(\rightarrow\) RE: \(O(n4^n)\)
\end{itemize}

\subsection{Abschlusseigenschaften regulärer Sprachen}
\label{sec:orgeee56c4}
\subsubsection{Satz 3.24}
\label{sec:orge86b350}
Seien \(R,R_1, R_2 \subseteq \Sigma^*\) reguläre Sprachen. Dann sind auch
\begin{itemize}
\item \(R_1R_2\)
\item \(R_1 \cup R_2\)
\item \(R^*\)
\item \(\bar{R} (:= \Sigma^* \backslash R)\)
\item \(R_1 \cup R_2\)
\item \(R_1 \backslash R_2\) \\
\end{itemize}
reguläre Sprachen

\begin{enumerate}
\item Produkt-Konstruktion
\label{sec:orgcbbddc5}
Für den Schnitt ist die De-Morgan regel zu teuer also kann man auch eine Produkt Konstruktion ohne Umweg über De-Morgen benutzen.

Das funktioniert über Parallelismus also beide DFAs laufen synchron parallel (kreuzprodukt der Zustandsräume).
\end{enumerate}

\subsubsection{Satz 3.24 Abschlusseigenschaften regulärer Sprachen}
\label{sec:org8660f6d}
Seien \(R. R_1,R_2 \subseteq \sum^*\) reguläre Sprachen. Dann sind auch
\(R_1R_2, R_1 \cup R_2, R^k, \bar{R} (:= \sum^* \backslash R), R_1 \cap R_2, R_1 \backslash R_2\) auch reguläre Sprachen

\subsubsection{Satz 3.25}
\label{sec:org0aaa7a5}
Sind \(M_1 = (Q_1, \sum,\delta_1,s_1,F_1)\) und \(M_2 = (Q_2,\sum,\delta_2,s_s, F_2)\) DFAs, dann ist der \textbf{Produkt-Automat}\\
\indent\indent\indent\indent \(M := (Q_1 \times Q_2, \sum, \delta, (s_1,s_2), F_1 \times F_2)\) \\
\indent\indent\indent\indent \(\delta((q_1,q_2), a) := (\delta_1(q_1, a), \delta_2(q_2, a))\)
\subsection{Rechnen mit Regulären Ausdrücken}
\label{sec:orgc8c8ea7}
\subsubsection{Definition 3.26}
\label{sec:org032f9b1}
Zwei reguläre Ausdrücke sind \textbf{äquivalent gdw} sie die gleiche Sprache darstellen:
\(\alpha \equiv \beta: \Leftrightarrow L(\alpha) = L(\beta)\)

(by the way \(\equiv\) steht für Bedeutungsäquivalenz und \(=\) für syntaktische gleichheit)

\subsubsection{Lemma 3.27}
\label{sec:org886a7b6}
\begin{itemize}
\item \(\emptyset | \alpha \equiv \alpha | \emptyset \equiv \alpha\)
\item \(\emptyset \alpha \equiv \alpha\emptyset \equiv \emptyset\)
\item \(\epsilon\alpha \equiv \alpha\epsilon \equiv \alpha\)
\item \(\emptyset^* \equiv \epsilon\)
\item \(\epsilon^* \equiv \epsilon\)
\end{itemize}

\subsubsection{Lemma 2.8}
\label{sec:org92fd318}
\begin{itemize}
\item Assozitiviät
\item Kommutativität
\item Distributivität
\begin{itemize}
\item \(\alpha(\beta | \gamma) \equiv \alpha\beta | \alhpa\gamma\)
\item \((\alpha | \beta)\gamma \equiv \alpha\gamma | \beta\gamma\)
\end{itemize}
\item Idempotenz: \(\alpha | \alpha \equiv \alpha\)
\end{itemize}

\subsection{Pumping Lemma}
\label{sec:org6285deb}
Wie zeigt man, dass eine Sprache nicht regulär ist?
\subsubsection{Satz 3.32 (Pumping Lemma für Reguläre Sprachen)}
\label{sec:org1272e3a}
Sei \(R \subseteq \Sigma^*\) regulär. Dann gibt es ein \(n > 0\), so dass sich jedes \(z \in R\) mit \(|z| \geq n\) so in \(z = uvw\) zerlegen lässt, dass
\begin{itemize}
\item \(v \neq \epsilon\),
\item \(|uv| \leq n\)
\item \(\forall i \geq 0. uv^iw \in R\). \\
\end{itemize}

Es gibt nicht-reguläre Sprachen, für die das Pumping-Lemma gilt!
\(\Rightarrow\) Pumping-Lemma hinreichend aber nicht notwendig um Nicht-Regularität zu zeigen.

regulär  \(\subset\) Pumping-Lemma gilt \(\subset\) alle Sprachen

\subsection{Entscheidungsverfahren}
\label{sec:org6a582f7}

\textbf{Eingabe:} Ein oder mehrere Objekte, die Reguläre Sprachen beschreiben (DFA, NFA, RE Typ3 Gram, \ldots{})
\textbf{Frage:} Haben die Sprachen die Eigenschaft X?
Ein (Entscheidungs-)Problem ist entscheidbar, wenn es einen Algorithmus gibt, der bei jeder Eingabe in endlicher Zeit die richtige Antwort auf die Frage feststellt.

Welche Entscheidungsprobleme sind für rechtslineare Grammatiken entscheidbar und wie hängt die Laufzeit mit der Beschreibung zusammen.

\subsubsection{Definition 3.37}
\label{sec:org019852f}
Sei D ein DFA, NFA, RE, rechtslineare Grammatik \ldots{}
\begin{itemize}
\item \textbf{Wortproblem}: Gegeben \(w\) und D: gilt \(w \in L(D)\)
\item \textbf{Leerheitsproblem}: Gegeben D: gilt \(\emptyset = L(D)\)
\item \textbf{Endlichkeitsproblem}: Gegeben D: isz \(L(D)\) endlich
\item \textbf{Äquivalenzproblem}: Gegeben \(D_1, D_2\), gilt \(L(D_1) = L(D_2)\)
\end{itemize}

\subsection{Automaten und Gleichungssysteme}
\label{sec:orgb73a5a9}
Wir werden jetzt aus einem Automat ein Gleichungssystem machen um daraus einen RE zu machen.

\subsubsection{Ardens Lemma (Satz 3.47)}
\label{sec:orgba2618a}
Sind A, B und X Sprachen mit \(\epsilon \not \in A\), so gilt
\(X = AX \cup B \Rightarrow X = A^*B\)
\subsubsection{Korollar 3.48}
\label{sec:org61f5ed1}
Sind \(\alpha, \beta\) und X reguläre Ausdrücke mit \(\epsilon \not \in L(\alpha)\), so gilt
\(X \equiv  \alpha X|\beta \Rightarrow X \equiv \alpha^*\beta\)
\subsubsection{Algorithmus um RE aus Automat zu machen}
\label{sec:org0482c21}

\begin{enumerate}
\item Wandle FA mit n Zuständen in ein System von n Gleichungen
\item Löse das System durch schrittweise Elimination von Variablen mit Hilfe von Ardens Lemma für REs (Korollar 3.48).
\item Ist k der Startzustand, so beschreibt X\textsubscript{k} die vom Automaten akzeptierte Sprache.
\end{enumerate}

\subsection{Minimierung endlicher Automaten}
\label{sec:org02a03b4}
\textbf{TODO MIA}

\subsection{Äquivalenztest von DFAs}
\label{sec:orgc2c990e}
Zwei Automaten sind genau äquivalent wenn:
\begin{enumerate}
\item Gegeben DFAs \(M1\) und \(M2\), bilde disjunkte Vereiningung. \\
(”Male M1 und M2 nebeneinander.“)
\item Berechne Menge der äquivalenten Zustände.
\item L(M1) = L(M2) gdw die beiden Startzustände äquivalent sind
\end{enumerate}

\subsection{Äquivalenz von Zuständen}
\label{sec:org6b9d388}
Zwei Zustände sind äquivalent wenn sie selbe Sprache akzeptieren.


\subsection{Minimalität des Quotientenautomaten}
\label{sec:orgb639384}

Die Residualsprache von L bzgl \(w \in \Sigma^*\) ist die Menge:

\(L^w := \{z \in \Sigma^* | wz \in L\}\)

\(L' \subseteq \Sigma^*\) ist Residualsprache von L wenn es \(w\) gibt mit \(L' = L^w\)

\subsubsection{Definition 3.55 (Äquivalenz von Wörtern bzgl. L)}
\label{sec:org8e50afd}
(Intuition: Zwei Wörter sind äquivalent wenn sie die gleiche Residualsprache haben.)

\textbf{zwei Wörter sind äquivalent gdw sie zu den gleichen Zuständen führen}

\subsubsection{Satz 3.56}
\label{sec:orgb925bd7}
Sei M ein DFA ohne unerreichbare Zustände. Der Quotientenautomat \(M / \equiv\) ist ein minimaler DFA für \(L(M)\).

\subsection{Definition 3.57 (Kanonischer Minimalautomat)}
\label{sec:orga04ccff}
\(M_L := (R_L, \Sigma, \delta_L, L, F_L)\)
mit \(\delta_L(R, a) := R^a\) und \(F_L := {R \in RL | \varepsilon \in R}\).
\(\delta_L\) ist wohldefiniert und \(\hat{\delta}}_L(R, w) = R^w\). Jeder Zustand \(R\) erkennt
die Sprache \(R\) und somit \(L(M_L) = L\).
\subsubsection{Satz 3.58}
\label{sec:orgcbc3585}
Jeder minimaler DFA für eine reguläre Sprache L unterscheidet sich vom kanonischen Minimalautomaten ML nur durch eine
\subsection{Satz 3.59}
\label{sec:org1403d0d}
Eine Sprache \(L \subseteq \Sigma^*\) ist genau dann regulär, wenn sie endlich viele Residualsprachen hat.
\end{document}
