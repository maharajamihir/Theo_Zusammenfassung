#+TITLE: Einführung in die Theoretische Informatik Zusammenfassung
#+author: Ali, Mihir, Noah

* Formale Sprachen

** Grundbegriffe
- Alphabet $\Sigma$ (endliche Menge) z.B. $\{1,0\}$
- Wort/String über $\Sigma$ ist eine endliche Folge von Zeichen aus $\Sigma$
- $|w|$ länge des Wortes $w$
- Leeres Wort $\epsilon$
- $uv$ konkatenation der Wörter $u$ und $w$
- Ist $w$ ein Wort so ist $w^0 = \epsilon$ und $w^{n+1} = ww^n$
- $\Sigma^*$ Menge aller Wörter über $\Sigma$
- (formale) Sprache $L \subseteq \Sigma^*$

*** Operationen auf Sprachen
Seien $A,B \subseteq \Sigma^*$
- Konkatenation:
$AB = \{uv | u \in A \land v \in B \}$
- Konkatenation mit sich selbst:
$A^n = \{w_1 ... w_n | w_1, ... , w_n \in A\} = A ... A$
- $A^* = \{w_1...w_n | n \geq 0 \land w_1, ... , w_n \in A\} = \bigcup_{n\in \mathbb{N}} A^n$
- $A^+ = AA^* = \bigcup_{n \geq 1} A^n$
**** Sonderfälle:
- $\forall A: \epsilon \in A^*$
- $\emptyset^* = \{\epsilon\}$
- $\emptyset A = \emptyset$
- $\{\epsilon \} A = A$
- $A^*A^* = A^* = (A^*)^*$

*** Grammatiken
4-Tupel $G = (V,\Sigma,P,S)$
- $V$ ist endliche Menge von Nichtterminalzeichen
- $\Sigma$ ist endliche Menga von Terminalzeichen (= Alphabet)
- $P \subseteq (V \cup \Sigma)^* \times (V \cup \Sigma)^*$ ist Menge von Produktionen
- $S \in V$ ist das Startsymbol

Die Sprache von G ist die Menge aller Wörter, die von G erzeugt werden. Sie wird mit $L(G)$ bezeichnet.
Also jedes Wort, dass die Grammatik erzeugt muss in der Sprache erhalten sein und jedes Wort in der Sprache muss von der Grammatik erzeugt werden.
**** Reflexve transitive Hülle

- $\alpha \rightarrow^0_G \alpha$
- $\alpha \rightarrow^{n+1}_G \gamma: \exists \beta. \alpha \rightarrow^n_G \rightarrow_G \gamma$
- $\alpha \rightarrow^{*}_G \beta : \exists n. \alpha \rightarrow^n_G \beta$
- $\alpha \rightarrow^{+}_G \beta: \exists n>0. \alpha \rightarrow^n_G \beta$

*** Chomsky Hierarchie
Eine Grammatik G ist vom
- Typ 0 immer
- Typ 1 falls fpr jede Produktion $\alpha \rightarrow \beta$ außer $S \rightarrow \epsilon$ gilt $|\alpha| \leq |\beta|$
- Typ 2 Falls G vom typ 1 ist und für jede Produktion $\alpha \righarrow \beta$ gilt $\alpha \in V$
- Typ 3 falls G vom Typ 2 ist und für jede Produktion $\alpha \rightarrow \beta$ außer $S \rightarrow \epsilon$ gilt $\beta \in \Sigma \cup \Sigma V$

**** Grmmatiken und Sprachklassen:
| Typ 3 | Rechtslineare Grammatiken  | Reguläre Sprachen             |
| Typ 2 | Kontextfreie Grammatik     | Kontextfreie Sprachen         |
| Typ 1 | Kontextsensitive Grammatik | Kontextsens. Sprachen         |
| Typ 0 | Phrasenstrukturgrammatik   | Rekursiv aufzählbare Sprachen |

**** Satz 2.13
$L(Typ 3) \subset L(Typ 2) \subset L(Typ 1) \subset L(Typ 0)$

*** Wortproblem
Gegeben: eine Grammatik G, ein Wort $w \in \Sigma^*$
Frage: Ist das Wort in w enthalten ($w \in L(G)$)?

* Reguläre Sprachen

#+CAPTION: Reguläre Sprachen Schema
[[./img/2-kapitel/reguläre_sprachen.png]]

** Deterministische endliche Automaten
#+CAPTION: Beispiel Automat
[[./img/2-kapitel/automat_bsp.png]]

- Beispiel:
  - Eingabewort $baba \rightarrow$ Zustandsfolge 0,0,1,2,2
- "Bei dieser Grammatik muss mindestens nach einem a ein b kommen"
- Die Sprache des DFA ist die Menge aller Wörter über $\{a,b\}$, die ab enthalten

Erkannte Sprache: Menge der Wörter, die vom Startzustand in einen Endzustand führen.
Recognizer, die nur einmal das Wort durchläuft und in linearer Zeit es akzeptiert oder ablehnt.

*** Definition
Ein deterministischer endlicher Automat $M = (Q,\Sigma, \delta, q_0, F)$ besteht aus
- endliche Menge von Zuständen Q
- endlichem Eingabealphabet $\Sigma$
- einer totalen Übergangsfunktion $\delta: Q \times \Sigma \rightarrow Q$
- eienm Startzustand $q_0 \in Q$
- einer Menge $F \subset Q$ von Endzuständen

**** Akzeptierte Sprachen (Definition 3.2)
Von M akzeptierte Sprache $L(M) := \{w \in \Sigma^* | \hat{\delta}(q_0, w) \in F\}$ wobei \\
$\hat{\delta}: Q \times \Sigma^* \rightarrow Q$ induktiv definiert ist: \\
$\hat{\delta}(q,\epsilon) = q$ \\
$\hat{\delta}(q,aw) = \hat{\delta}(\delta(q,a),w)$, für $a \in \Sigma, w \in \Sigma^*$ \\
($\hat{\delta}(q, w)$ bezeichnet den Zustand, den man aus $q$ mit $w$ erreicht.)\\
Eine Sprache ist regulär *gdw* sie von einem DFA akzeptiert wird.

**** Beispiel Automat der Sprache akzeptiert
Induktiv beweisen pro Zustand.


** Von rechtslinearen Grammatiken zu DFA
- Für jede rechtslineare Grammatik $G$ gibt es einen DFA $M$ mit $L(M) = L(G)$
- Für jeden DFA $M$ gibt es eine rechtslineare Grammatik $G$ mit $L(G) = L(M)$

*** Nichtdeterministischer endlicher Automat
Ein deterministischer endlicher Automat $M = (Q,\Sigma, \delta, q_0, F)$ besteht aus
- $Q, \Sigma, q_0, F$ sind wie DFA
- $\delta: Q \times \Sigma \rightarrow P(Q)$ \\
  $P(Q)$ = Menge aller Teilmengen von $Q = 2^Q$ \\
  Alternative: Relation $\delta \subseteq Q \times \Sigma \times Q$


$\bar{\delta}(S,a) := \bigcup_{q \in S} \delta(q,a)$


Es folgt: $\hat{\bar{\delta}}: P(Q) \times \Sigma^* \rightarrow P(Q)$

**** Intuition:
$\hat{\bar{\delta}}(S,w)$ ist Menge aller Zustände, die sich von einem Zustand in S aus $w$ erreichen lassen.

**** Von nichtdeterminitsichen Automaten N akzeptierte Sprache
$L(N) := \{w \in \Sigma^* | \hat{\bar{\delta}}(\{q_0\},w) \cap F \neq \emptyset\}$

*** Satz 3.9
Für jede rechtslineare Grammatik G gibt es einen NFA M mit $L(G) = L(M)$
*** Satz 3.13
Für jeden DFA M gibt es eine rechtslineare Grammatik G mit $L(M) = L(G)$

** 3.3 NFAs mit $\epsilon$ -Übergängen
Grammatiken von Programmiersprachen enthalten viele Produktionen der Gestalt $A \rightarrow B$.

Ein NFA mit *$\epsilon$*-Übergängen (auch $\epsilon$ -NFA) ist ein NFA mit einem speziellen Symbol $\epsilon \not \in \Sigma$ und mit
$\delta : Q \times (\Sigma \cup {\epsilon}) \rightarrow P(Q)$ .
Ein $\epsilon$ übergang darf ausgef¨uhrt werden, ohne dass ein

*** Lemma 3.16
Für jeden $\epsilon$ -NFA $N$ gibt es einen NFA $N'$ mit $L(N) = L(N')$.

** 3.4 Regex
- $\emptyset$ ist ein regex
- $\epsilon$ ist ein regex
- Für jedes $a \in \Sigma$ ist a ein regulärer Audruck
- Wenn $\alpha$ und $\beta$ regex dann auch
  1. $\alpha \beta$
  2. $\alpha | \beta$
  3. $\alpha^*$
- Sonst NIX!
*** Definition 3.20
Zu einem regulären Ausdruck $\gamma$ ist die zugehörige Sprache $L(\gamma)$ rekursiv definiert:
- $L(\emptyset) =\emptyset$
- $L(\epsilon) = \{\epsilon\}$
- $L(a) = {a}$
- $L(\alpha \beta) = L(\alpha)L(\beta))$
- $L(\alpha | \beta) = L(\alpha) \cup L(\beta)$
- $L(\alpha^*) = L(\alpha)^*$

*** Satz 3.23 (Kleene 1956)
Eine Sprache $L \subseteq \Sigma^*$ ist genau dann durch einen regulären Ausdruck darstellbar, wenn sie regulär ist.\\
\smallindent
$R^{k+1}_{ij} = R^k_{ij} \cup R^k_{i(k+1)}(R^k_{(k+1)(k+1)})^*R^k_{(k+1)j}$ /in regex $\cup = |$/\\
$R^{k+1}_{ij}$ = alle Wörter die in $R^k_{ij}$ sind plus alle Wörter die mindestens einmal $q_{k+1}$ besuchen
Somit gilt $L(M) = L(\alpha^n_{1i_1} | ... | \alpha^n_{1i_r})$, wobei $F=\{i_1, ..., i_r\}$


*** Wie teuer sind unsere Konversionen?
[[./img/2-kapitel/konversionen.png]]
- RE $\rightarrow \epsilon$ -NFA: RE der Länge n, $O(n)$ Zustände
- $\epsilon$ -NFA $\rightarrow$ NFA: Q
- NFA $\rightarrow$ DFA: $O(2^n)$
- FA $\rightarrow$ RE: $O(n4^n)$

** Abschlusseigenschaften regulärer Sprachen
*** Satz 3.24
Seien $R,R_1, R_2 \subseteq \Sigma^*$ reguläre Sprachen. Dann sind auch
- $R_1R_2$
- $R_1 \cup R_2$
- $R^*$
- $\bar{R} (:= \Sigma^* \backslash R)$
- $R_1 \cup R_2$
- $R_1 \backslash R_2$ \\
reguläre Sprachen

**** Produkt-Konstruktion
Für den Schnitt ist die De-Morgan regel zu teuer also kann man auch eine Produkt Konstruktion ohne Umweg über De-Morgen benutzen.

Das funktioniert über Parallelismus also beide DFAs laufen synchron parallel (kreuzprodukt der Zustandsräume).

*** Satz 3.24 Abschlusseigenschaften regulärer Sprachen
Seien $R. R_1,R_2 \subseteq \sum^*$ reguläre Sprachen. Dann sind auch
$R_1R_2, R_1 \cup R_2, R^k, \bar{R} (:= \sum^* \backslash R), R_1 \cap R_2, R_1 \backslash R_2$ auch reguläre Sprachen

*** Satz 3.25
Sind $M_1 = (Q_1, \sum,\delta_1,s_1,F_1)$ und $M_2 = (Q_2,\sum,\delta_2,s_s, F_2)$ DFAs, dann ist der *Produkt-Automat*\\
\indent\indent\indent\indent $M := (Q_1 \times Q_2, \sum, \delta, (s_1,s_2), F_1 \times F_2)$ \\
\indent\indent\indent\indent $\delta((q_1,q_2), a) := (\delta_1(q_1, a), \delta_2(q_2, a))$
** Rechnen mit Regulären Ausdrücken
*** Definition 3.26
Zwei reguläre Ausdrücke sind *äquivalent gdw* sie die gleiche Sprache darstellen:
$\alpha \equiv \beta: \Leftrightarrow L(\alpha) = L(\beta)$

(by the way $\equiv$ steht für Bedeutungsäquivalenz und $=$ für syntaktische gleichheit)

*** Lemma 3.27
- $\emptyset | \alpha \equiv \alpha | \emptyset \equiv \alpha$
- $\emptyset \alpha \equiv \alpha\emptyset \equiv \emptyset$
- $\epsilon\alpha \equiv \alpha\epsilon \equiv \alpha$
- $\emptyset^* \equiv \epsilon$
- $\epsilon^* \equiv \epsilon$

*** Lemma 2.8
- Assozitiviät
- Kommutativität
- Distributivität
  - $\alpha(\beta | \gamma) \equiv \alpha\beta | \alhpa\gamma$
  - $(\alpha | \beta)\gamma \equiv \alpha\gamma | \beta\gamma$
- Idempotenz: $\alpha | \alpha \equiv \alpha$

** Pumping Lemma
Wie zeigt man, dass eine Sprache nicht regulär ist?
*** Satz 3.32 (Pumping Lemma für Reguläre Sprachen)
Sei $R \subseteq \Sigma^*$ regulär. Dann gibt es ein $n > 0$, so dass sich jedes $z \in R$ mit $|z| \geq n$ so in $z = uvw$ zerlegen lässt, dass
- $v \neq \epsilon$,
- $|uv| \leq n$
- $\forall i \geq 0. uv^iw \in R$. \\

Es gibt nicht-reguläre Sprachen, für die das Pumping-Lemma gilt!
$\Rightarrow$ Pumping-Lemma hinreichend aber nicht notwendig um Nicht-Regularität zu zeigen.

regulär  $\subset$ Pumping-Lemma gilt $\subset$ alle Sprachen

** Entscheidungsverfahren

*Eingabe:* Ein oder mehrere Objekte, die Reguläre Sprachen beschreiben (DFA, NFA, RE Typ3 Gram, ...)
*Frage:* Haben die Sprachen die Eigenschaft X?
Ein (Entscheidungs-)Problem ist entscheidbar, wenn es einen Algorithmus gibt, der bei jeder Eingabe in endlicher Zeit die richtige Antwort auf die Frage feststellt.

Welche Entscheidungsprobleme sind für rechtslineare Grammatiken entscheidbar und wie hängt die Laufzeit mit der Beschreibung zusammen.

*** Definition 3.37
Sei D ein DFA, NFA, RE, rechtslineare Grammatik ...
- *Wortproblem*: Gegeben $w$ und D: gilt $w \in L(D)$
- *Leerheitsproblem*: Gegeben D: gilt $\emptyset = L(D)$
- *Endlichkeitsproblem*: Gegeben D: isz $L(D)$ endlich
- *Äquivalenzproblem*: Gegeben $D_1, D_2$, gilt $L(D_1) = L(D_2)$

** Automaten und Gleichungssysteme
Wir werden jetzt aus einem Automat ein Gleichungssystem machen um daraus einen RE zu machen.

*** Ardens Lemma (Satz 3.47)
Sind A, B und X Sprachen mit $\epsilon \not \in A$, so gilt
$X = AX \cup B \Rightarrow X = A^*B$
*** Korollar 3.48
Sind $\alpha, \beta$ und X reguläre Ausdrücke mit $\epsilon \not \in L(\alpha)$, so gilt
$X \equiv  \alpha X|\beta \Rightarrow X \equiv \alpha^*\beta$
*** Algorithmus um RE aus Automat zu machen

1. Wandle FA mit n Zuständen in ein System von n Gleichungen
2. Löse das System durch schrittweise Elimination von Variablen mit Hilfe von Ardens Lemma für REs (Korollar 3.48).
3. Ist k der Startzustand, so beschreibt X_k die vom Automaten akzeptierte Sprache.

** Minimierung endlicher Automaten
